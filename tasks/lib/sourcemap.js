/*
 * grunt-contrib-concat
 * http://gruntjs.com/
 *
 * Copyright (c) 2013 "Cowboy" Ben Alman, contributors
 * Licensed under the MIT license.
 */

'use strict';

exports.init = function( grunt ) {
  var exports = {};

  var path = require('path');

  var SourceMapConsumer = require('source-map').SourceMapConsumer;
  var SourceMapGenerator = require('source-map').SourceMapGenerator;
  var SourceNode = require('source-map').SourceNode;

  // Return an object that is used to track sourcemap data between calls.
  exports.object = function(banner, footer, options) {
    var node = new SourceNode();
    node.add(banner);
    // Force sourcesContent if the source has been edited.
    if (options.stripBanners || options.process) {
      if (!options.sourceMap.content) {
        grunt.warn(
          'stripBanners or process option is enabled. ' +
          'Set sourceMap.content option to true.'
        );
      }
      options.sourceMap.content = true;
    }
    return {
      banner: banner,
      footer: footer,
      maps: [],
      node: node
    };
  };

  // Add some arbitraty text to the sourcemap.
  exports.add = function( sourceObject, src, options ) {
    sourceObject.node.add(src);
  };

  // Add the lines of a given file to the sourcemap. If in the file, store a
  // prior sourcemap and return src with sourceMappingURL removed.
  exports.addlines = function(
    sourceObject, src, filename, options
  ) {
    var lines = src.split('\n');
    src = lines.map(function(line, j) {
      // Add back a linefeed to all but the last line.
      if (j < lines.length - 1) {
        line += '\n';
      }

      if (
        /\/\/[@#]\s+sourceMappingURL=(.+)/.test(line) ||
          /\/\*#\s+sourceMappingURL=([^\s]+)\s+\*\//.test(line)
      ) {
        var sourceMapFile = RegExp.$1;
        var sourceMapPath = filename.replace(/[^\/]*$/, sourceMapFile);

        var sourceContent;
        // Browserify, as an example, stores a datauri at sourceMappingURL.
        if (/data:application\/json;base64,([^\s]+)/.test(sourceMapFile)) {
          sourceContent = new Buffer(RegExp.$1, 'base64').toString();
        } else {
          sourceContent = grunt.file.read(sourceMapPath);
        }
        var sourceMap = JSON.parse(sourceContent);
        // The source map generated by sass 3.3.0.rc.1 seems to be wrong format.
        if (typeof sourceMap.version === 'string') {
          sourceMap.version = parseInt(sourceMap.version, 10);
        }
        if (typeof sourceMap.names === 'undefined') {
          sourceMap.names = [];
        }
        // List the filename argument for the source map.
        sourceMap.file = filename;
        // Store the sourceMap so that it may later be consumed.
        sourceObject.maps.push(sourceMap);
        // Remove the old sourceMappingURL.
        line = line.replace(/[@#]\s+sourceMappingURL=[^\s]+/, '');
      }

      sourceObject.node.add(new SourceNode(j + 1, 0, filename, line));
      return line;
    }).join('');

    if (options.sourceMap.content) {
      sourceObject.node.setSourceContent(filename, src);
    }

    return src;
  };

  // Return the comment sourceMappingURL that must be appended to the
  // concatenated file.
  exports.url = function(sourceObject, f, options) {
    sourceObject.node.add(sourceObject.footer);

    // Create the map filepath. Either datauri or destination path.
    var mapfilepath;
    if (options.sourceMap.inline) {
      mapfilepath = 'data:application/json;base64,' + new Buffer(
        this.write(sourceObject, f, options)
      ).toString('base64');
    } else {
      mapfilepath = f.dest.substring(f.dest.lastIndexOf('/') + 1) + '.map';
    }
    // Create the sourceMappingURL.
    var url;
    if (/\.css$/.test(f.dest)) {
      url = '\n/*# sourceMappingURL=' + mapfilepath + ' */';
    } else {
      url = '\n//# sourceMappingURL=' + mapfilepath;
    }
    // Record the created url.
    sourceObject.node.add(url);
    // For not inlined source, write the map file.
    if (!options.sourceMap.inline) {
      this.write(sourceObject, f, options);
    }
    return url;
  };

  // Return a string for inline use or write the source map to disk.
  exports.write = function(sourceObject, f, options) {
    var code_map = sourceObject.node.toStringWithSourceMap({
      file: f.dest,
      sourceRoot: options.sourceMap.root
    });
    // Consume the new sourcemap.
    var generator = SourceMapGenerator.fromSourceMap(
      new SourceMapConsumer(code_map.map.toJSON())
    );
    // Consume sourcemaps for source files.
    sourceObject.maps.forEach(function(sourceMap){
      generator.applySourceMap(new SourceMapConsumer(sourceMap));
    });
    // New sourcemap.
    var newSourceMap = generator.toJSON();
    newSourceMap.file = path.basename(newSourceMap.file);
    // Return a string for inline use or write the map.
    if (options.sourceMap.inline) {
      return JSON.stringify(newSourceMap, null, '  ');
    } else {
      grunt.file.write(
        f.dest + '.map',
        JSON.stringify(newSourceMap, null, '  ')
      );
    }
  };

  return exports;
};
